### 第7章 更灵活的定位内存地址的方法
#### 7.1 and 和 or 指令
    1>and指令  按位与
    2>or指令   按位或
#### 7.2 关于ASCII码
#### 7.3 以字符形式给出的数据
#### 7.4 大小写转换的问题
    大写字母的第5位为0,小写字母的第5位为1
#### 7.5 [bx+idata]
#### 7.6 用[bx+idata]的方式进行数组处理
    mov ax,datasg
    mov ds,ax
    mov bx,0

    mov cx,5 
 s: mov al,0[bx]
    and al,11011111b 
    mov 0[bx],al
    mov al,5[bx]
    or al,00100000b 
    mov 5[bx], al 
    inc bx
    loop s 

#### 7.7 SI和DI 
    si和di是8086CPU中和bx功能相近的寄存器,si和di不能分为两个8位寄存器.
    代码片段：
    codesg segment 
    start: mov ax, datasg 
           mov ds,ax 
           mov si,0
           mov cx,8 
        s: mov ax,0[si]
           mov 16[si],ax 
           add si,2 
           loop s 

           mov ax,4c00h 
           int 21h 
    codesg ends 
    end start 

#### 7.8 [bx+si]和[bx+di]
    mov ax,[bx+si]即 (ax) = ((ds) * 16 + (bx)+(si))
#### 7.9 [bx+si+idata] 和 [bx+di+idata]
    mov ax,[bx+si+idata] 即 (ax) = ((ds)*16 + (bx) + (si) + idata)
#### 7.10 不同的寻址方式的灵活应用 
```
assume cs:codesg,ds:datasg,ss:stacksg 
datasg segment 
    db 'ibm            '
    db 'dec            '
    db 'dos            '
    db 'vax            '
datasg ends 
stack segment 
dw 0,0,0,0,0,0,0,0 
stack ends 

codesg segment 
    start: mov ax,stacksg
           mov ss,ax 
           mov sp,16 
           mov ax,datasg 
           mov ds,ax 
           mov bx,0 
           mov cx,4 
    s0:    push cx 
           mov si,0 
           mov cx,3 
       s:  mov al,[bx+si]
           and al,11011111b 
           mov [bx+si], al 
           inc si 
           loop s 

           add bx,16 
           pop cx 
           loop s0 

           mov ax,4c00h 
           int 21h 
codesg ends 
end start 
```

### 实验6