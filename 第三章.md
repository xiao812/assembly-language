### 第三章 寄存器(内存访问)
#### 3.1 内存中字的存储 
    大端序和小端序
#### 3.2 DS和[address]
**8086CPU不支持将数据直接送入段寄存器**

    mov bx,1000h
    mov ds,bx
    mov al,[0]

#### 3.3 字的传送

#### 3.4 mov、add、sub指令 
    mov指令可以有一下几种形式
    mov 寄存器,         数据
    mov 寄存器,         寄存器 
    mov 寄存器,         内存单元
    mov 内存单元,       寄存器 
    mov 段寄存器,       寄存器 
    mov 寄存器,         段寄存器 
    mov 内存单元,       段寄存器
    mov 段寄存器,       内存单元

**add和sub不能用于段寄存器**

    addh和sub指令同mov大致一样 
    add 寄存器,         数据
    add 寄存器,         寄存器
    add 寄存器,         内存单元
    add 内存单元,       寄存器
    sub 寄存器,         数据
    sub 寄存器,         寄存器
    sub 寄存器,         内存单元
    sub 内存单元,       寄存器

#### 3.5 数据段
    数据和程序没有区别。
#### 3.6 栈
    LIFO(Last In First Out) 后进先出
#### 3.7 CPU提供的栈机制
**8086CPU的入栈和出栈都是以字为单位进行的**

    8086CPU中,有两个寄存器,段寄存器SS和寄存器SP,栈顶的段地址存放在SS中,偏移地址存放在SP中.任意时刻,SS:SP指向栈顶元素。
    push ax的执行:
    1>SP = SP -2,SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶
    2>将ax中的内容送入SS:SP指向的内存单元初,SS:SP此时指向新栈顶
    pop  ax的执行
    1>将 SS:SP指向的元素放到ax中
    2>SP=SP+2, SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶

#### 3.8 栈顶超界的问题
    8086CPU无解决方案

#### 3.9 push、pop指令
    push和pop指令形式:
    push    寄存器
    pop     寄存器
    push    段寄存器
    pop     段寄存器
    push    内存单元
    pop     内存单元

#### 3.10 栈段
    最大为64KB

### 实验2 用机器指令和汇编指令编程 
#### 1.Debug的使用
    1> -d 段寄存器:偏移地址
    2> E、A、U命令和D命令一样
    