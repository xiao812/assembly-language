### 第12章 内中断

#### 12.1 内中断的产生
    1>除法错误
    2>单步执行
    3>执行into指令
    4>执行int指令
#### 12.2 中断处理程序

#### 12.3 中断向量表
    从内存0000:0000 到0000：03FF的1024个单元中存放着中断向量表

#### 12.4 中断过程
    1>(从中断信息中)取得中断类型码
    2>标志寄存器的值入栈(因为在中断过程中要改变标志寄存器的值，所以先将其保存在栈中)
    3>设置标志寄存器中的第8位TF和第9位IF的值为0 
    4>CS的内容入栈
    5>IP的内容入栈
    6>从内存地址为中断类型码*4 和 中断类型码*4+2的两个字单元中读取中断处理程序的入口地址设置IP和CS
 相当于:
    1>取得中断类型码N
    2>pushf 
    3>TF = 0, IF = 0 
    4>push CS 
    5>push IP 
    6>(IP)=(N*4),(CS) = (N*4+2)

#### 12.5 中断处理程序和iret指令
    中断处理程序的编写方法:
    1>保存用到的寄存器
    2>处理中断
    3>恢复用到的寄存器
    4>用iret指令返回

#### 12.6 除法错误中断的处理

#### 12.7 编写处理0号中断

#### 12.8 安装
    assume cs:code 
    code segment 

    start:  设置es:di指向目的地址
            设置ds:si指向源地址
            设置cx为传输长度
            设置传输方向为正
            rep movsb 

            设置中断向量表

            mov ax,4c00h 
            int 21h
    do0:    显示字符串"overflow!"
            mov ax,4c00h 
            int 21h 
    code ends 
    end start 

    assume cs:code 
    code segment 
    start:  mov ax,cs 
            mov ds,ax
            mov si,offset do0 
            mov ax,0
            mov es,ax 
            mov di,200h 

            mov cx, offset do0end-offset do0 

            cld 
            rep movsb 

            设置中断向量表

            mov ax,4c00h 
            int 21h 
      do0:  显示字符串"overflow!"
            mov ax,4c00h 
            int 21h 
    
    do0end: nop 

    code ends 
    end start 

#### do0 
    do0: 设置ds:si指向字符串
         mov ax,0b800h 
         mov es,ax 
         mov di, 12*160 + 36 * 2 ; 设置es:di 指向现存空间的中间位置 

         mov cx,9 
     s:  mov al,[si]
         mov es:[di],al
         inc si 
         add di,2 
         loop s 

         mov ax,4c00h 
         int 21h 
    
do0end:   nop 

    完整程序:
    assume  cs:code 
    code segment 
    start:  mov ax,cs 
            mov ds,ax
            mov si,offset do0 
            mov ax,0
            mov es,ax 
            mov di,200h 
            mov cx,offset do0end-offset do0 
            cld 
            rep movsb 
            设置中断向量表

            mov ax,4c00h 
            int 21h 
     
     do0:   jmp short do0start 
            db "overflow!"
    
do0start:   mov ax,cs
            mov ds,ax 
            mov si,202h 

            mov ax,0b800h 
            mov es,ax
            mov di,12*160 + 36 * 2 

            mov cx,9 
        s:  mov al,[si]
            mov es:[di],al
            inc si 
            add di,2
            loop s 

            mov ax,4c00h 
            int 21h 
do0end:     nop 
code ends 
end start 

#### 12.10 设置中断向量
    mov ax,0
    mov es,ax
    mov word ptr es:[0*4],200h 
    mov word ptr es:[0*4+2],0 

#### 单步中断
    检测到标志寄存器的TF为1,则产生单步中断

#### 12.12 响应中断的特殊情况
    处理栈的时候