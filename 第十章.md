### CALL和RET指令
#### 10.1 ret和retf
    ret指令用栈中数据,修改IP的内容，从而实现近转移
    retf指令用栈中数据,修改CS和IP的内容，从而实现远转移
    CPU执行ret指令时，进行下面两部操作:
    (IP)  = ((SS) * 16 + (SP))
    (SP) = (sp) + 2
    相当于 POP IP
    CPU执行retf指令时，进行下面4步操作:
    (IP) = ((SS) * 16 + (SP))
    (SP) = (SP) + 2 
    (CS) = ((SS) * 16 + (SP))
    (Sp) = (SP) + 2 
    相当于  POP IP 
           POP CS 
    
#### 10.2 call指令
    1>将当前的IP或CS和IP压入栈中 
    2>转移

#### 10.3 依据位移进行转移的call指令
    call 标号(将当前的IP压栈后，转到标号处执行指令)
    1>(SP) = (SP) - 2 
      ((SS)*16 + (SP)) = (IP)
    2>(IP) = (IP) + 16位位移
    相当于   push IP 
            jmp near ptr 标号 

#### 10.4 转移的目的地址在指令中的call指令 
    call far ptr 标号实现的是段间转移 
    1> (SP) = (SP) - 2 
       ((ss)*16 + (sp)) = (CS)
       (SP) = (SP) - 2
       ((SS) * 16 + (SP)) = (IP)
    2> (CS) = 标号所在段的段地址 
       (IP) = 标号在段中的偏移地址 

    相当于push  CS 
          push IP 
          jmp far ptr 标号 

#### 转移地址在寄存器中的call指令 
    call 16位reg 
    (sp) = (sp) - 2 
    ((SS) * 16 + (sp)) = (ip)
    (ip) = (16位reg)
    相当于 push IP 
            jmp 16位reg 

#### 10.6 转移地址在内存中的call指令 
    两种格式: 
    1>call word ptr 内存单元地址 
    相当于 push IP  jmp word ptr 内存单元地址 

    2>call dword ptr 内存单元地址 
    相当于      push cs  push ip   jmp dword ptr 内存单元地址 

#### 10.7 call 和 ret 的配合使用 
    相当于子程序 

#### 10.8 mul指令
