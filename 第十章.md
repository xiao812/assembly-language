### CALL和RET指令
#### 10.1 ret和retf
    ret指令用栈中数据,修改IP的内容，从而实现近转移
    retf指令用栈中数据,修改CS和IP的内容，从而实现远转移
    CPU执行ret指令时，进行下面两部操作:
    (IP)  = ((SS) * 16 + (SP))
    (SP) = (sp) + 2
    相当于 POP IP
    CPU执行retf指令时，进行下面4步操作:
    (IP) = ((SS) * 16 + (SP))
    (SP) = (SP) + 2 
    (CS) = ((SS) * 16 + (SP))
    (Sp) = (SP) + 2 
    相当于  POP IP 
           POP CS 
    
#### 10.2 call指令
    1>将当前的IP或CS和IP压入栈中 
    2>转移

#### 10.3 依据位移进行转移的call指令
    call 标号(将当前的IP压栈后，转到标号处执行指令)
    1>(SP) = (SP) - 2 
      ((SS)*16 + (SP)) = (IP)
    2>(IP) = (IP) + 16位位移
    相当于   push IP 
            jmp near ptr 标号 

#### 10.4 转移的目的地址在指令中的call指令 
    call far ptr 标号实现的是段间转移 
    1> (SP) = (SP) - 2 
       ((ss)*16 + (sp)) = (CS)
       (SP) = (SP) - 2
       ((SS) * 16 + (SP)) = (IP)
    2> (CS) = 标号所在段的段地址 
       (IP) = 标号在段中的偏移地址 

    相当于push  CS 
          push IP 
          jmp far ptr 标号 

#### 转移地址在寄存器中的call指令 
    call 16位reg 
    (sp) = (sp) - 2 
    ((SS) * 16 + (sp)) = (ip)
    (ip) = (16位reg)
    相当于 push IP 
            jmp 16位reg 

#### 10.6 转移地址在内存中的call指令 
    两种格式: 
    1>call word ptr 内存单元地址 
    相当于 push IP  jmp word ptr 内存单元地址 

    2>call dword ptr 内存单元地址 
    相当于      push cs  push ip   jmp dword ptr 内存单元地址 

#### 10.7 call 和 ret 的配合使用 
    相当于子程序 

#### 10.8 mul指令
    格式 mul reg 或 mul 内存单元  
    mul byte ptr ds:[0]  相当于 (ax) = (al)*((ds)*16 + 0);
    mul word ptr [bx+si+8] 相当于 
    (ax)=(ax)*((ds)*16+(bx)+(si)+8)结果的低16位
    (dx)=(ax)*((ds)*16+(bx)+(si)+8)结果的高16位

#### 10.9 模块化程序设计

#### 10.10 参数和结果的传递的问题
    assume cs:code 
    data segment 
        dw 1,2,3,4,5,6,7,8 
        dd 0,0,0,0,0,0,0,0
    data ends 
    code segment 
    start:  mov ax,data 
            mov ds,ax 
            mov si,0
            mov di,16 

            mov cx,8 
        s:  mov bx,[si]
            call cube 
            mov [di],ax
            mov [di].2,dx
            add si,2
            add di,4
            loop s 

            mov ax,4c00h 
            int 21h 
     cube:  mov ax,bx 
            mul bx
            mul bx
            ret 
    code ends 
    end start 

#### 10.11 批量数据的传递
    capital: and byte ptr [si], 11011111b ;将ds:si 所指单元中的字母转化为大写
             inc si
             loop capital 
             ret 

    assume cs:code 
    data segment
        db 'conversation'
    data ends 

    code segment 
        start: mov ax,data 
               mov ds,ax 
               mov si,0
               mov cx,12 
               call capital 
               mov ax,4c000h 
               int 21h 
            
     capital: and byte ptr [si],11011111b 
              inc si 
              loop capital 
              ret 
    code ends 
    end start 

#### 10.12 寄存器冲突的问题 
    编写子程序的标准框架:
        子程序使用的寄存器入栈
        子程序内容
        子程序中使用的寄存器出战
        返回 ret retf

### 实验10 编写子程序
